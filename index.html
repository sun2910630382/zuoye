<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
      /*this 值------------------------------------------------------------------------------------------------------------------*/
      //this 函数中一个特殊变量，所有函数中都有this，在实际开发时有特殊意义，使用this会很方便。
      //构造函数中
      //例
      var lilei = {high:180,age:20,color:'white'};
      var hanmeimei = {high:170,age:23,color:'yellow'};
      //Person  构造函数，创建人的对象。
      function Person(){
          //在函数体里定义对象的模板
        this.high = 180;
        this.age = 20;
        this.color ='white' ;
        //这里的this就是要创建的对象
      }
      var lilei=new Person();
      console.log(lilei);
      //在方法中
      var obj={
          talk:function(){
            //这里的this是指谁调用的方法，this就是谁。
          }
      }
      obj.this();
      //普通函数
      function foo(){
          console.log(this);
          //在普通函数中，this代表的是window对象
      }
      foo();
      var f=new foo();
      //此时的this为f,因为此时是构造函数
      /*---------------------------------------------------事件--------------------------------------------------------------*/
      //-----------------------------------------事件作用
      /*HTML事件就是发生在HTML元素上的事情，事件就是为了实现服务器与用户的交互，或者是在HTML某个元素上发生一些事情时，可以对其做一些处理。*/
      //------------------------------------------事件的绑定
      //1.DOM0级事件绑定方式
      /*通过HTML一些事件的特性来实现事件的绑定（在发生某些事件时触发）
      与HTML页面具有较高的耦合度
      事件处理的函数中this没有绑定
      事件对象的获取要通过window.event,会相当的麻烦*/
      //2.DOM2级时间绑定方式
      /*通过DOM一些事件相关属性来实现事件的绑定
      与HTML页面完全解耦
      事件处理函数中的this绑定到了事件源(当前发生事件的元素)
      事件对象也可以通过处理函数中的形参来获取
      但是无法给同一事件绑定多个处理函数
      */
      //3.DOM事件绑定方法
      /*addEventListener(type,handler)
      removeEventListener(type,handler)移除，解绑事件（处理函数）
      attchEvent(type,handler)IE标准
      detachEvent(type,handler)
      */
      //-------------------------------------------事件委托
      //当某个或某些页面上的元素触发某一事件，自己本身不绑定该事件(自己不处理)，通过事件冒泡原理，他的父节点也会受到该事件，由其父节点去办理这种处理方式叫事件委托
      /*---------------------------------------------------动画原理------------------------------------------------*/
      //因为人眼视觉是有0.1s的延迟，，所以几张图片切换间隔小于0.1s就会产生动画的效果。
      //setInterval(()=>{},50)
      /*-------------------------------------------------原型-----------------------------------------------------*/
      //对象间数据共享的问题
      /*所有数据都有prototype属性，该属性引用一个对象。
      所有由该函数创建的对象都可以直接访问其原型属性所引用的对象上所有的成员(属性，方法)*/
      //优化构造函数写法
      /*区分对象共有属性和方法以及私有属性和方法
      将私有的成员写在构造函数中
      将共有成员写在原型对象中*/
      /*------------------------------------------------面向对象-------------------------------------------*/
      //面向对象三大特性
      /*1.封装性：可以保证数据的私密性和安全性，让数据在一定范围内可见，如果想要访问数据一般我们可以制定一个或多个数据访问接口。
      2.继承性：代码的复用，在JS中如果对象A有权访问对象B的成员，那么就可以说对象A继承自对象B。
        子类(超类)：对象A
        父类(基类)：对象B
      3.多态性：体现在继承关系中的。
      Java的强类型的语言，如果变量或函数参数被定义为父类类型，那么该变量或参数不仅可以接受父类类型值，也可以接受其所有子类类型值
      方法重写：如果父类继承下来的方法不完全或不符合当前子类的要求，那么可以在子类中，重新定义该同名方法。
      ***函数(方法)重载：Java,C++允许定义重名的方法和函数也不会覆盖，在JS里也允许，但会覆盖。
      返回值 不同
      参数个数 不等
      参数类型 不同
      */
      /*-----------------------------------------------------闭包-----------------------------------------*/
      /*闭包概念(js中)
    闭包就是指一个可以访问其他函数内部数据的函数。*/
    //闭包特点
    /*函数嵌套函数
    内部函数可以使用外部函数的内部变量(形参)
    函数中的局部变量在外部是不能被引用(保护函数内的变量安全)
    内部函数是外部函数的返回值
    外层函数一旦执行，就会创建一个新的闭包。而不同闭包之间的数据是独立的。*/
    //闭包的优缺点
    /*避免全局变量污染
    将函数内部变量的值始终保存在内存中(缓存)
    通过保护变量的安全实现js私有属性和私有方法(不能被外部访问)
    缺点
    使用闭包，会增大内存的开销，如果滥用闭包，就会有造成内存泄露的风险。
    内存泄漏:计算机的内存被一点一点沾满，从而不能再定义其他变量或数据。
    内存溢出:储存数据所需要的内存空间，超过计算机所剩下的内存空间。因此在开辟内存时，就会有溢出。*/
    /*-------------------------------------------------单线程机制-------------------------------------------*/
    /*GUI渲染线程
    Graphical User Interface
    当GUI自上向下解析时，一旦碰到了script标签，就会中断GUI线程的渲染。开始将js代码放入JS主线程开始执行，如果执行时遇到了定
    时器，那么就会开辟一个线程来计时，这个线程叫计时线程。为了让计时线程里的任务到时间后能回到主线程里继续执行，出现了任务队列。
    当计时线程中的任务到时间后，就会进入任务队列排队。当JS主线程没有任务可作时，就会进入任务队列中寻找是否有任务等待执行，如果有，
    就 会将任务拿到主线程中执行。
    用户行为   AJAX请求   promise对像都可能进入任务队列
    promise优先级高于定时器
    setTimeOut是异步代码：代码执行时，可以不等到结果出来，就可以继续向下执行*/
    /*----------------------------------------Es6常用语法-------------------------------------------------------*/
    //类class
    /*class 类名{
        //原型方法
        say(){}
    }*/
    //私有实例字段
    /*
    私有实例字段是通过**# names**句型（读作“哈希名称”）声明的，即为识别符加一个前缀“#”。“#”是名称的一部分，也用于访问和声明。
    封装是语言强制实施的。引用不在作用域内的 # names 是语法错误。
    class ClassWithPrivateField {
        #privateField;
  
        constructor() {
        this.#privateField = 42;
        this.#randomField = 666; # Syntax error
        }
    }

    const instance = new ClassWithPrivateField();
    instance.#privateField === 42; // Syntax error
    ```*/
    //数组新增方法
    /* forEach()数组循环便利
    map()映射
    filter()
    indexOf()
    */
    /*--------------------------------------------promise-------------------------------------------------*/
    /*`Promise` 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
//Promise`对象有以下两个特点。
（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的
结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。
只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会
立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。*/
    </script>
</body>
</html>